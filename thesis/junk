
def autoplot(main, axes):
   r,c=0,0
   print(r, c)
   for i in range(6):
     main(r, c, axes)
     if i % 2 != 0:
       r+=1
       c =0
     elif i % 2 == 0 or i==1:
       c=1   
   
def main(r,c, axes):
    axis=axes[r][c]
    # Create the figure and subplots
    map_plot=buildings_rain_aggr.plot(ax=axis, column=column, cmap="RdBu", scheme="quantiles", k=10, alpha=0.9,edgecolor='0.6')
    axis.grid()
    # Figure title
    fig.suptitle('Seasonal temperature observations - Helsinki Malmi airport')
    plt.title('linear')
    # Rotate the x-axis labels so they don't overlap
    plt.setp(axis.xaxis.get_majorticklabels(), rotation=20)  
    map_plot.set_facecolor("#eeeeee")
    minx,miny,maxx,maxy =  buildings_rain_aggr.total_bounds
    # these are matplotlib.patch.Patch properties
    props = dict(boxstyle='round', facecolor='#eaeaea', alpha=0)
    map_plot.text(x=minx+1000,y=maxy-5000, s=u'N \n\u25B2 ', ha='center', fontsize=20, weight='bold', family='Courier new', rotation = 0)
    map_plot.text(x=425000,y=maxy-2000, s='lowo',  ha='center', fontsize=20, weight='bold', family='Courier new', bbox=props)
    #ax11.text(datetime(2013, 2, 15), -25, 'Winter')
    plt.setp(axis.xaxis.get_majorticklabels(), rotation=20)
    colorbar(map_plot)
#    plt.tight_layout()
    plt.savefig(r'C:\Users\oyeda\Desktop\msc\test.jpg')



fig, axes = plt.subplots(nrows=3, ncols=2, figsize=(12,12), sharex=True, sharey=True) 
   
autoplot(main=main, axes=axes)



#making a classifier with natural breaks of 5 classes
classifier = ps.Natural_Breaks.make(k=7)
#Now we can apply that classifier into our data quite similarly as in our previous examples.

# Classify the data
classifications = buildings_rain_aggr[['Sep_rainPOT']].apply(classifier)



buildings_rain_aggr.plot(ax=ax, column=column, cmap="RdBu", scheme="quantiles", k=10, alpha=0.9)

plt.subplot(nrows=2, ncols=3,sharex, sharey, label)
plt.subplot(pos, **kwargs)
plt.subplot(ax)





fig, axes = plt.subplots(ncols=2)
fig, axes = plt.subplots(nrows=2, ncols=2, figsize=(12,8), sharex=True, sharey=True)
# add geopandas plot to left subplot
buildings_rain_aggr.plot(ax=axes[0,0], column=column, cmap="RdBu", legend=True, scheme="quantiles", k=10, alpha=0.9, edgecolor='0.6')
buildings_rain_aggr.plot(ax=axes[0,1], column=column, cmap="RdBu", legend=True, scheme="quantiles", k=10, alpha=0.9, edgecolor='0.6')

geodataframe.plot(..., ax=axes[0])


import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors

# Create the figure and subplots
fig, axes = plt.subplots(nrows=2, ncols=2, figsize=(12,8), sharex=True, sharey=True)
# Rename the axes for ease of use
ax11 = axes[0][0]
ax12 = axes[0][1]
ax21 = axes[1][0]
ax22 = axes[1][1]

# Set the plotted line width
line_width = 1.5

# Plot data
buildings_rain_aggr.plot(ax=ax11, column=column, cmap="RdBu", legend=True, scheme="quantiles", k=10, alpha=0.9,edgecolor='0.6')
buildings_rain_aggr.plot(ax=ax12, column=column, cmap="RdBu", scheme="quantiles", k=10, alpha=0.9)
buildings_rain_aggr.plot(ax=ax21, column=column, cmap="RdBu", scheme="quantiles", k=10, alpha=0.9)
buildings_rain_aggr.plot(ax=ax22, column=column, cmap="RdBu", scheme="quantiles", k=10, alpha=0.9)


leg = ax11.get_legend()
leg.set_bbox_to_anchor((0., 0., 0.5, 0.5))


# Set y-axis limits
minx,miny,maxx,maxy =  buildings_rain_aggr.total_bounds
#ax11.set_ylim(miny, maxy)
#ax12.set_ylim(miny, maxy)
#ax21.set_ylim(miny, maxy)
#ax22.set_ylim(miny, maxy)

# Turn plot grids on
ax11.grid()
ax12.grid()
ax21.grid()
ax22.grid()

# Figure title
fig.suptitle('Seasonal temperature observations - Helsinki Malmi airport')

# Rotate the x-axis labels so they don't overlap
plt.setp(ax11.xaxis.get_majorticklabels(), rotation=20)
plt.setp(ax12.xaxis.get_majorticklabels(), rotation=20)
plt.setp(ax21.xaxis.get_majorticklabels(), rotation=20)
plt.setp(ax22.xaxis.get_majorticklabels(), rotation=20)

# Axis labels
ax21.set_xlabel('Date')
ax22.set_xlabel('Date')
ax11.set_ylabel('Temperature [deg. C]')
ax21.set_ylabel('Temperature [deg. C]')

# Season label text
#ax11.text(datetime(2013, 2, 15), -25, 'Winter')
#ax12.text(datetime(2013, 5, 15), -25, 'Spring')
#ax21.text(datetime(2013, 8, 15), -25, 'Summer')
#ax22.text(datetime(2013, 11, 15), -25, 'Fall')

fig

# =============================================================================
from rasterio.plot import show
from rasterio.plot import show_hist
from rasterio.mask import mask
from shapely.geometry import box
import geopandas as gpd
from fiona.crs import from_epsg
import pycrs
import matplotlib.pyplot as plt
from osgeo import gdal
import utm
from rasterToPolygon import polygonize
import clip_raster
import numpy as np
import geopandas as gpd
from shapely.geometry import Polygon
import numpy as np
# =============================================================================

import rasterio
from rasterio.plot import show
from rasterio.plot import show_hist
from rasterio.mask import mask
import geopandas as gpd
from shapely.geometry import box
import seaborn as sns
import glob
import os
import calendar
import re
import pysal as ps

from rasterToPolygon import polygonize
import clip_raster as ras


# =============================================================================
# 
# =============================================================================
aoi_crs_epsg = {'init' :'epsg:32737'}
aoi_crs_epsg_code = 32737
rain_raster_data_epsg_code = 4326

#readthe shapefile for the area of interest
#aoi_shapefile = gpd.read_file(r'E:\LIDAR_FINAL\data\AOI\fishnet_926_1sqm.shp')
aoi_shapefile=gpd.read_file(r'E:\LIDAR_FINAL\data\2015\buildings\buildings_2015_simplified.shp')


#bbox_aoi2 = ras.get_vector_extent(aoi_shapefile)'
#bbox_aoi = ras.get_vector_extent(aoi_shapefile)
#bbox_aoi = ras.get_raster_extent(r'E:\LIDAR_FINAL\data\AOI\clipped_mean_annual_rain.tif')
#bbox_aoi = [38.19986023835, -3.2418059025499986, 38.52486023705, -3.516805901449999]


# =============================================================================
# #LOAD THE FILEPATH
# =============================================================================
#mean_annual_filepath = r'E1:\LIDAR_FINAL\data\precipitation\mean_annual\CHELSA_bio_12.tif'
#mean_annual_clipped_path = r'E:\LIDAR_FINAL\data\precipitation\mean_annual\mean_annual_rain_clipped.tif'
#mean_annual_rain_raster = rasterio.open(mean_annual_filepath)
#clip the mean annual rainfall raster data
#mean_annual_rain_clipped = ras.get_clipped_raster(mean_annual_rain_raster, mean_annual_clipped_path,
#                                                  bbox_aoi, 4326)

#READ THE VALUES OF THE JUST CLIPPED RASTER
#mean_annual_rain = rasterio.open(mean_annual_clipped_path).read().astype(float)


#SPECIFY PLOT SIZE IN THE CONSOLE
plt.rcParams['figure.figsize'] = (4, 12) 


#PLOT
sns.set_style("white")
# Plot newly classified and masked raster
fig, ax = plt.subplots(figsize = (3,2))
#show((mean_annual_rain_clipped, 1),cmap='Blues', title="Mean Annual Rainfall")
#show((clipped, 1), cmap='Blues', title="Mean Annual Rainfall", contour=True)




# =============================================================================
# WORKING WITH THE BUILDING SHAPEFILE
# =============================================================================
buildings_fp = r'E:\LIDAR_FINAL\data\2015\buildings\buildings_2015_simplified.shp'
buildings_shp = gpd.read_file(buildings_fp)

# calculate area and centroid of the buildings
buildings_shp['area'] = buildings_shp['geometry'].area

# filter roof areas lower than 10sqm or higher than 2000sqm

buildings_shp = buildings_shp.loc[(buildings_shp['area']>10) & (buildings_shp['area']<2000)]

# get the centroid of every building
buildings_shp['centroid']= buildings_shp['geometry'].centroid
#buildings_shp['geometry'].representative_point()

buildings_centroid = buildings_shp.copy()
buildings_centroid['geometry'] = buildings_shp['centroid']
buildings_centroid = buildings_centroid.reset_index(drop=True)

#set ID for the filtered buildings. Start from one
buildings_centroid['ID'] =  buildings_centroid.index + 1
del buildings_centroid['centroid']


centroid_fp = r'E:\LIDAR_FINAL\data\2015\buildings_centroid\buildings_centroid.shp'
buildings_centroid.to_file(centroid_fp)
#buildings_centroid.plot()

# =============================================================================
# BOUNDING BOX FROM BUILDINGS' CENTROIDS
# =============================================================================
bbox_aoi = ras.get_vector_extent(buildings_centroid)


# =============================================================================
# # CLIP ALL THE MONTHLY DATA AND ALSO SUM THEM
# =============================================================================
sum_rain = 0
monthly_rain_raster = glob.glob(r'E:\LIDAR_FINAL\data\precipitation\mean_monthly\*.tif')
for i, month_file_path in enumerate(monthly_rain_raster, 1):
    print(i)
    filename = os.path.basename(month_file_path)
#    Match the first number in the file name which is the month
    if filename[:-4] == 'annual_rainfall':
        month_name = 'ann'
    else:
        month_number = re.search(r'\d+', filename).group()
        month_name = calendar.month_name[int(month_number)]
    month_abbreviation = month_name[:3]+'_rain'
    output_tif = os.path.join('E:/LIDAR_FINAL/data/precipitation/mean_monthly/clipped', month_abbreviation + '.tif')
    print(output_tif)
    ras.clip_and_export_raster(month_file_path, output_tif, bbox_aoi)
    
    month_raster = rasterio.open(output_tif).read().astype(float)
    sum_rain += month_raster


   

cc = sum_rain/12

show(sum_rain,cmap='Blues', title="Mean Annual Rainfall")

# =============================================================================
# CONVERT THE RASTER FILES INTO VECTOR
# =============================================================================
monthly_rain_clipped=glob.glob(r'E:\LIDAR_FINAL\data\precipitation\mean_monthly\clipped\*.tif')
for i, month_file in enumerate(monthly_rain_clipped, 1):
    month_field_name = os.path.basename(month_file)[:3] + '_rain'
    output_shp = os.path.join('E:/LIDAR_FINAL/data/precipitation/mean_monthly/clipped/to_vector', month_field_name + '.shp')
    print(month_field_name)
#    month_raster = rasterio.open(month_file)
    polygonized_raster = ras.polygonize(month_file, rain_raster_data_epsg_code, aoi_crs_epsg_code)
    polygonized_raster=polygonized_raster.rename(columns={'grid_value': month_field_name})
    polygonized_raster.to_file(output_shp)
    
#    FOR TEST PURPOSE
    month_rain_data_test = gpd.read_file(output_shp)
    month_rain_data_test.plot(column=month_field_name, cmap="Blues", scheme="equal_interval", k=9, alpha=0.9)

 



# =============================================================================
# 
# # CREATE A FISHNET/GRID OF 926.1m PIXEL
# =============================================================================
#generating grid by directly providing the bounding box
#grid = ras.create_grid(926.1, 926.1, bbox_aoi, is_utm=False)
#generating grid based on shapefile extent
grid = ras.create_grid(926.1, 926.1, convex_hull=False,shapefile=buildings_centroid)
grid['grid_ID'] = grid.index + 1
grid = grid.reset_index(drop=True)
grid.plot()
#grid = ras.create_grid(gridHeight=926.1, gridWidth=926.1,shapefile=aoi_shapefile)
#grid.plot()

grid_path = r'E:\LIDAR_FINAL\data\grid\grid.shp'
grid.to_file(grid_path)
# =============================================================================
# 
# =============================================================================




# =============================================================================
# SPATIAL JOIN
# =============================================================================
grid.crs = buildings_centroid.crs = aoi_crs_epsg
#grid['geometry'] = grid[0]
#grid_ = gpd.GeoDataFrame()
#grid_['geometry'] = None 
#grid_['geometry'] = grid.geometry
#gridm = grid.unary_union
#bb = buildings_centroid.within(gridm)
#subset = buildings_centroid[buildings_centroid.within(gridm)]
#subset.plot('area')
buildings_grid = gpd.sjoin(grid, buildings_centroid,how="inner", op='intersects')
del buildings_grid['index_right']
months_shp_filepaths = glob.glob(r'E:\LIDAR_FINAL\data\precipitation\mean_monthly\clipped\to_vector\*.shp')

#The op options determines the type of join operation to apply. op can be set to “intersects”, “within” or 
#“contains” (these are all equivalent when joining points to polygons, but differ when 
#joining polygons to other polygons or lines).
grid.plot()



buildings_grid.columns

# =============================================================================
# AGGREGATE ROOF AREAS BASED ON GRID ID
# =============================================================================

buildings_grouped = buildings_grid.groupby('grid_ID')
buildings_aggr = gpd.GeoDataFrame()
#buildings_aggr['geometry']=None
for key, (i, group ) in enumerate(buildings_grouped,1):
    print(i)
    group_geometry = group.iloc[0]['geometry']
    buildings_aggr.loc[key, 'grid_ID'] = key
    buildings_aggr.loc[key,'geometry'] = group_geometry
    buildings_aggr.loc[key,'area_sum'] = group['area'].sum()
    print('Aggregating', key, group['area'].sum())


buildings_aggr.plot('area_sum', linewidth=0.03, cmap="Blues", scheme="quantiles", k=19, alpha=0.9)



# =============================================================================
# AGGREGATE RAINFALL DATA
# =============================================================================

#3CREATE FUNCTION TO HELP WITH AGGREGATING THE DATA
#test['geometry'] = test.centroid
def aggregate_grid_rain(new_dataframe, old_dataframe, month_field_name):
    grouped_data = old_dataframe.groupby('grid_ID')
    #buildings_aggr['geometry']=None
    for key, (i, group ) in enumerate(grouped_data,1):
        group_geometry = group.iloc[0]['geometry']
        new_dataframe.loc[key,'geometry'] = group_geometry
        new_dataframe.loc[key, 'grid_ID'] = key
        new_dataframe.loc[key, month_field_name] =round(group[month_field_name].mean(), 2)
        print('Aggregating', key, month_field_name, group[month_field_name].mean())
#        
        if i == len(new_dataframe):
            new_dataframe.loc[key,'area_sum'] = group['area_sum'].sum()
    return new_dataframe


# =============================================================================
# SPATIAL JOIN OF RAINFALL AND ROOF AREAS TO GRID DATA
# =============================================================================

months_shp_filepaths = glob.glob(r'E:\LIDAR_FINAL\data\precipitation\mean_monthly\clipped\to_vector\*.shp')


buildings_rain_aggr = gpd.GeoDataFrame()
buildings_rain  = buildings_aggr.copy()
#del buildings_rain['area']
for i, month_filepath in enumerate(months_shp_filepaths, 1):  
    print(i)
    month_rain_data = gpd.read_file(month_filepath)
    
    buildings_rain.crs = month_rain_data.crs=  aoi_crs_epsg
    
    joined_data = gpd.sjoin(buildings_rain, month_rain_data, how='inner', op='intersects')
    
#    Get field name from file name and exclude the file format
    month_field_name = os.path.basename(month_filepath)[:-4]
    print(month_field_name)
    
    buildings_rain_aggr = aggregate_grid_rain(buildings_rain_aggr, joined_data, month_field_name)
    

# =============================================================================
# PLOT THE ROOF AREA AND RAINFALL DATA
# =============================================================================

for column in buildings_rain_aggr.columns[2:]:
    buildings_rain_aggr.plot(column=column, cmap="Blues", scheme="equal_interval", k=9, alpha=0.9)
    print(column)
    


# =============================================================================
#     CALCULATE MONTHLY RAINWATER HARVESTING POTENTIALS
# =============================================================================
#buildings_rain_aggr = buildings_rain_aggr.fillna(0)
for column in buildings_rain_aggr.columns:
    if column in ['geometry', 'grid_ID', 'area_sum']:
        continue
    roof_coefficient = 0.7
    roof_area = buildings_rain_aggr['area_sum']
    rainfall = buildings_rain_aggr[column]
    
#    1 m2) * 1 mm = 1litre. roof area is m2 and rain is in mm.
    roof_harvesting_potential = (roof_area * rainfall * roof_coefficient)
    buildings_rain_aggr[column + 'POT'] =round(roof_harvesting_potential, 2)
    print(buildings_rain_aggr.columns)


# =============================================================================
# PLOT ROOF HARVESTING POTENTIAL FOR ALL MONTHS
# =============================================================================
for column in buildings_rain_aggr.columns:
    if column.endswith('rainPOT'):
        buildings_rain_aggr.plot(column=column, cmap="RdBu", scheme="quantiles", k=10, alpha=0.9, edgecolor='1')
        print(column)
#edgecolor='0.8
buildings_rain_aggr.describe()


# =============================================================================
# TODO:
# HISTOGRAM FOR MONTHLY AND ANNUAL RAINFALL
# HISTOGRAM FOR ROOF SIZE DISTRIBUTION
# HISTOGRAM FOR ROOF POTENTIAL FOR ALL MONTHS
# HISTOGRAM FOR ANNUAL ROOF POTENTIAL
#
#
#
# =============================================================================





#
#
#import pandas as pd
#import numpy as np
#import shapely
#import matplotlib.pyplot as plt
#from mpl_toolkits.axes_grid1 import make_axes_locatable
#
#
#
#gdf = buildings_rain_aggr
### the plotting
##buildings_rain_aggr.plot(column=column, cmap="RdBu", scheme="quantiles", k=10, alpha=0.9, edgecolor='1')
#       
#vmin, vmax = buildings_rain_aggr['ann_rainPOT'].min(), buildings_rain_aggr['ann_rainPOT'].max()
#
#ax = gdf.plot(column='ann_rainPOT', colormap='RdBu',  scheme="quantiles", k=10, alpha=0.9, edgecolor='1')
##ax = gdf.plot(column='ann_rainPOT', colormap='RdBu', vmin=vmin, vmax=vmax)
## add colorbar
#fig = ax.get_figure()
#sm = plt.cm.ScalarMappable(cmap='RdBu', norm=plt.Normalize(vmin=vmin, vmax=vmax))
#divider = make_axes_locatable(ax)
#cax = divider.append_axes("right", size="5%", pad=0.05)
## fake up the array of the scalar mappable. Urgh...
#sm._A = []
#cbar=fig.colorbar(sm, cax=cax)
#cbar.set_label('Litres')
#
#
#
#
#import numpy as np
#import matplotlib.pyplot as plt
#import matplotlib.colors
#
##  r,c=0,0
##  main(r, c)
##  for i in range(6):
##    if i % 2 != 0:
##      r+=1
##      c =0
##    elif i % 2 == 0 or i==1:
##      c=1 
#
#
#
#def colorbar(ax):
##  vmin, vmax = buildings_rain_aggr['ann_rainPOT'].min(), buildings_rain_aggr['ann_rainPOT'].max()
#
##  ax = gdf.plot(column='ann_rainPOT', colormap='RdBu',  scheme="quantiles", k=10, alpha=0.9, edgecolor='1')
##ax = gdf.plot(column='ann_rainPOT', colormap='RdBu', vmin=vmin, vmax=vmax)
## add colorbar
#  fig = ax.get_figure()
#  sm = plt.cm.ScalarMappable(cmap='RdBu', norm=plt.Normalize(vmin=vmin, vmax=vmax))
#  divider = make_axes_locatable(ax)
#  cax = divider.append_axes("right", size="5%", pad=0.05)
## fake up the array of the scalar mappable. Urgh...
#  sm._A = []
#  cbar=fig.colorbar(sm, cax=cax)
#  cbar.set_label('Litres')
#
#
#def autoplot(r=0,c=0,main=None):
#  fig, axes = plt.subplots(nrows=3, ncols=2, figsize=(12,12), sharex=True, sharey=True)    
#  r,c=0,0
#  for i in range(6):
#    main(r=r, c=c, axes=axes)
#    if i % 2 != 0:
#      r+=1
#      c =0
#    elif i % 2 == 0 or i==1:
#      c=1   
#  
#def main(r,c, axes):
#  axis=axes[r][c]
#  # Create the figure and subplots
#  map_plot=buildings_rain_aggr.plot(ax=axis, column=column, cmap="RdBu", scheme="quantiles", k=10, alpha=0.9,edgecolor='0.2')
#  
#  axis.grid()
#  # Figure title
#  fig.suptitle('Seasonal temperature observations - Helsinki Malmi airport')
#  minx,miny,maxx,maxy =  buildings_rain_aggr.total_bounds
#  map_plot.text(x=minx+1000,y=maxy-5000, s='^ \nN ', ha='center', fontsize=20, family='Courier new', rotation = 0)
#  plt.setp(axis.xaxis.get_majorticklabels(), rotation=20)
#  colorbar(map_plot)
#  plt.tight_layout()
#  plt.savefig(r'C:\Users\oyeda\Desktop\msc\test.jpg')
#
#autoplot(main=main)
#
#  
#
#
## Rename the axes for ease of use
#ax11 = axes[0][0]
#ax12 = axes[0][1]
#ax21 = axes[1][0]
#ax22 = axes[1][1]
#
## Set the plotted line width
#line_width = 1.5
#
## Plot data
#buildings_rain_aggr.plot(ax=ax11, column=column, cmap="RdBu", legend=True, scheme="quantiles", k=10, alpha=0.9,edgecolor='0.6')
#buildings_rain_aggr.plot(ax=ax12, column=column, cmap="RdBu", scheme="quantiles", k=10, alpha=0.9)
#buildings_rain_aggr.plot(ax=ax21, column=column, cmap="RdBu", scheme="quantiles", k=10, alpha=0.9)
#buildings_rain_aggr.plot(ax=ax22, column=column, cmap="RdBu", scheme="quantiles", k=10, alpha=0.9)
#
#
#leg = ax11.get_legend()
#leg.set_bbox_to_anchor((0., 0., 0.5, 0.5))
#
#
## Set y-axis limits
#minx,miny,maxx,maxy =  buildings_rain_aggr.total_bounds
##ax11.set_ylim(miny, maxy)
##ax12.set_ylim(miny, maxy)
##ax21.set_ylim(miny, maxy)
##ax22.set_ylim(miny, maxy)
#
## Turn plot grids on
#ax11.grid()
#ax12.grid()
#ax21.grid()
#ax22.grid()
#
## Figure title
#fig.suptitle('Seasonal temperature observations - Helsinki Malmi airport')
#
## Rotate the x-axis labels so they don't overlap
#plt.setp(ax11.xaxis.get_majorticklabels(), rotation=20)
#plt.setp(ax12.xaxis.get_majorticklabels(), rotation=20)
#plt.setp(ax21.xaxis.get_majorticklabels(), rotation=20)
#plt.setp(ax22.xaxis.get_majorticklabels(), rotation=20)
#
## Axis labels
#ax21.set_xlabel('Date')
#ax22.set_xlabel('Date')
#ax11.set_ylabel('Temperature [deg. C]')
#ax21.set_ylabel('Temperature [deg. C]')
#
## Season label text
##ax11.text(datetime(2013, 2, 15), -25, 'Winter')
##ax12.text(datetime(2013, 5, 15), -25, 'Spring')
##ax21.text(datetime(2013, 8, 15), -25, 'Summer')
##ax22.text(datetime(2013, 11, 15), -25, 'Fall')
#
#fig
#
#plt.savefig(r'C:\Users\oyeda\Desktop\msc\test.jpg')
#
#
#









useful for plotting houses
buildings_rain_aggr.plot(ax=ax11, column=column,c=np.log10(buildings_rain_aggr['ann_rainPOT']), cmap="RdBu", scheme="quantiles", k=10, alpha=0.9,edgecolor='0.6')

plt.scatter(buildings_centroid['geometry'].x, buildings_centroid['geometry'].y)
lon = buildings_centroid['geometry'].x
lat =buildings_centroid['geometry'].y
# Extract the data we're interested in
buildings_rain_aggr['ann_rainPOT']
buildings_centroid.columns


minx,miny,maxx,maxy =  buildings_rain_aggr.total_bounds
#lat, lon = cities['latd'], cities['longd']
#population, area = cities['population_total'], cities['area_total_km2']
population, area = buildings_centroid['ID'], buildings_centroid['area']
# Scatter the points, using size and color but no label
plt.scatter(lon, lat, label=None,
            c=np.log10(population), cmap='viridis',
            s=area, linewidth=0, alpha=0.5)
plt.axis(aspect='equal')
plt.xlabel('longitude')
plt.ylabel('latitude')
plt.colorbar(label='log$_{10}$(population)')
plt.clim(3, 7)



import rasterio
from rasterio.plot import show
from rasterio.plot import show_hist
from rasterio.mask import mask
from shapely.geometry import box
import geopandas as gpd
from fiona.crs import from_epsg
import pycrs
import matplotlib.pyplot as plt
from osgeo import gdal
import utm



fp= r'E:\LIDAR_FINAL\data\precipitation\mean_annual\mean_annual_rainfall_clipped.tif'
out_tif=r'E:\LIDAR_FINAL\data\precipitation\mean_annual\test_lowo.tif'

# show((data, 1), cmap='terrain')
# plt.show()
grid_path = r'E:\LIDAR_FINAL\data\2015\fishnet\fishnet_925_1sqm.shp'


data = rasterio.open(fp)
fishnet = gpd.read_file(grid_path)
# print(fishnet.bounds)
# print(fishnet.total_bounds)
# fishnet.plot()
# plt.show()

bbox = fishnet.total_bounds
# print(bbox)
# print(fishnet.crs)
# print(from_epsg(32737))

minx, miny, maxx, maxy = bbox

# # min, max=bbox[0:2], bbox[2:4]
# # print(minx)
# min = utm.to_latlon(minx,miny, 37, northern=False)
# max = utm.to_latlon(maxx,maxy, 37, northern=False)

# # unpack the values from the tuple
# bbox_lat_lon = [*min, *max]
# print(bbox_lat_lon) 
# ds = gdal.Open(fp)
# ds = gdal.Translate('newl.tif', ds, projWin = bbox_lat_lon)
# ds = None



minx, miny = 3.30175, 38.13193 
maxx, maxy = 3.14038, 38.28565

# minx, miny = 24.60, 60.00
# maxx, maxy = 25.22, 60.35
# bbox = box(*bbox_lat_lon)
bbox = box(minx, miny, maxx, maxy)
print(bbox)
geo = gpd.GeoDataFrame({'geometry': bbox}, index=[0], crs=from_epsg(4326))
geo = geo.to_crs(crs=data.crs.data)

def getFeatures(gdf):
    """Function to parse features from GeoDataFrame in such a manner that rasterio wants them"""
    import json
    return [json.loads(gdf.to_json())['features'][0]['geometry']]

coords = getFeatures(geo)
print(coords)
out_img, out_transform = mask(raster=data, shapes=coords, crop=True)

# out_image, out_transform = mask(data, fishnet, crop=True, invert=False)
# geo = gpd.GeoDataFrame({'geometry': bbox_lat_lon}, index=[0],crs=from_epsg(4326))
# geo.plot()
# plt.show()






# geo = geo.to_crs(crs=data.crs)

# def getFeatures(gdf):
#     """Function to parse features from GeoDataFrame in such a manner that rasterio wants them"""
#     import json
#     return [json.loads(gdf.to_json())['features'][0]['geometry']]

# coords = getFeatures(geo)







# print(coords)

# out_img, out_transform = mask(raster=data, shapes=coords, crop=True)

# out_meta = data.meta.copy()

# print(out_meta)

# epsg_code = int(data.crs.data['init'][5:])

# print(epsg_code)

# out_meta.update({"driver": "GTiff",
#                      "height": out_img.shape[1],
#                      "width": out_img.shape[2],
#                      "transform": out_transform,
#                      "crs": pycrs.parser.from_epsg_code(epsg_code).to_proj4()})

# with rasterio.open(out_tif, "w", **out_meta) as dest:dest.write(out_img)

# clipped = rasterio.open(out_tif)

# show((clipped, 5), cmap='terrain')

# RasterClipper.py - clip a geospatial image using a shapefile






#test['geometry'] = test.centroid
def aggregate_grid_rain(grid_data, rain_data, crs_code, ):
    grid_data.crs = kkr.crs= {'init' :'epsg:' + str(crs_code)}
    kk = gpd.sjoin(kk, kkr, how='left', op='intersects')
    kk_grouped = kk.groupby('grid_ID')
    buildings_rain_aggr = gpd.GeoDataFrame()
    #buildings_aggr['geometry']=None
    for key, group  in kk_grouped:
        group_geometry = group.iloc[0]['geometry']
        buildings_rain_aggr.loc[key, 'grid_ID'] = key
        buildings_rain_aggr.loc[key,'geometry'] = group_geometry
        buildings_rain_aggr.loc[key,'Apr_rain'] = group['Apr_rain'].mean()
        print('Aggregating', key, group['Apr_rain'].mean())







# RasterClipper.py - clip a geospatial image using a shapefile

import operator
from osgeo import gdal, gdalnumeric, ogr, osr
import Image, ImageDraw

# Raster image to clip
raster = "SatImage.tif"

# Polygon shapefile used to clip
shp = "county"

# Name of clip raster file(s)
output = "clip"

# This function will convert the rasterized clipper shapefile 
# to a mask for use within GDAL.    
def imageToArray(i):
    """
    Converts a Python Imaging Library array to a 
    gdalnumeric image.
    """
    a=gdalnumeric.fromstring(i.tostring(),'b')
    a.shape=i.im.size[1], i.im.size[0]
    return a

def arrayToImage(a):
    """
    Converts a gdalnumeric array to a 
    Python Imaging Library Image.
    """
    i=Image.fromstring('L',(a.shape[1],a.shape[0]),
            (a.astype('b')).tostring())
    return i
     
def world2Pixel(geoMatrix, x, y):
  """
  Uses a gdal geomatrix (gdal.GetGeoTransform()) to calculate
  the pixel location of a geospatial coordinate 
  """
  ulX = geoMatrix[0]
  ulY = geoMatrix[3]
  xDist = geoMatrix[1]
  yDist = geoMatrix[5]
  rtnX = geoMatrix[2]
  rtnY = geoMatrix[4]
  pixel = int((x - ulX) / xDist)
  line = int((ulY - y) / yDist)
  return (pixel, line) 

def histogram(a, bins=range(0,256)):
  """
  Histogram function for multi-dimensional array.
  a = array
  bins = range of numbers to match 
  """
  fa = a.flat
  n = gdalnumeric.searchsorted(gdalnumeric.sort(fa), bins)
  n = gdalnumeric.concatenate([n, [len(fa)]])
  hist = n[1:]-n[:-1] 
  return hist

def stretch(a):
  """
  Performs a histogram stretch on a gdalnumeric array image.
  """
  hist = histogram(a)
  im = arrayToImage(a)   
  lut = []
  for b in range(0, len(hist), 256):
    # step size
    step = reduce(operator.add, hist[b:b+256]) / 255
    # create equalization lookup table
    n = 0
    for i in range(256):
      lut.append(n / step)
      n = n + hist[i+b]
  im = im.point(lut)
  return imageToArray(im)

# Load the source data as a gdalnumeric array
srcArray = gdalnumeric.LoadFile(raster)

# Also load as a gdal image to get geotransform 
# (world file) info
srcImage = gdal.Open(raster)
geoTrans = srcImage.GetGeoTransform()

# Create an OGR layer from a boundary shapefile
shapef = ogr.Open("%s.shp" % shp)
lyr = shapef.GetLayer(shp)
poly = lyr.GetNextFeature()

# Convert the layer extent to image pixel coordinates
minX, maxX, minY, maxY = lyr.GetExtent()
ulX, ulY = world2Pixel(geoTrans, minX, maxY)
lrX, lrY = world2Pixel(geoTrans, maxX, minY)

# Calculate the pixel size of the new image
pxWidth = int(lrX - ulX)
pxHeight = int(lrY - ulY)

clip = srcArray[:, ulY:lrY, ulX:lrX]

# Create a new geomatrix for the image
geoTrans = list(geoTrans)
geoTrans[0] = minX
geoTrans[3] = maxY

# Map points to pixels for drawing the 
# boundary on a blank 8-bit, 
# black and white, mask image.
points = []
pixels = []
geom = poly.GetGeometryRef()
pts = geom.GetGeometryRef(0)
for p in range(pts.GetPointCount()):
  points.append((pts.GetX(p), pts.GetY(p)))
for p in points:
  pixels.append(world2Pixel(geoTrans, p[0], p[1]))
rasterPoly = Image.new("L", (pxWidth, pxHeight), 1)
rasterize = ImageDraw.Draw(rasterPoly)
rasterize.polygon(pixels, 0)
mask = imageToArray(rasterPoly)   

# Clip the image using the mask
clip = gdalnumeric.choose(mask, \
    (clip, 0)).astype(gdalnumeric.uint8)

# This image has 3 bands so we stretch each one to make them
# visually brighter
for i in range(3):
  clip[i,:,:] = stretch(clip[i,:,:])

# Save ndvi as tiff
gdalnumeric.SaveArray(clip, "%s.tif" % output, \
    format="GTiff", prototype=raster)

# Save ndvi as an 8-bit jpeg for an easy, quick preview
clip = clip.astype(gdalnumeric.uint8)
gdalnumeric.SaveArray(clip, "%s.jpg" % output, format="JPEG")